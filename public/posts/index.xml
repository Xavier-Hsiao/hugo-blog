<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>文章列表 on 哥布林 . 一起 . 強大</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in 文章列表 on 哥布林 . 一起 . 強大</description>
    <generator>Hugo -- 0.140.2</generator>
    <language>zh-tw</language>
    <lastBuildDate>Sun, 16 Feb 2025 13:09:10 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>慢速工作力 - 打破生產力迷思</title>
      <link>http://localhost:1313/posts/reading/%E6%85%A2%E9%80%9F%E5%B7%A5%E4%BD%9C%E5%8A%9B---%E4%B9%9F%E8%A8%B1%E6%88%91%E5%80%91%E9%83%BD%E8%AA%A4%E6%9C%83%E7%94%9F%E7%94%A2%E5%8A%9B%E7%9A%84%E6%84%8F%E7%BE%A9%E4%BA%86/</link>
      <pubDate>Mon, 27 Jan 2025 10:18:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/reading/%E6%85%A2%E9%80%9F%E5%B7%A5%E4%BD%9C%E5%8A%9B---%E4%B9%9F%E8%A8%B1%E6%88%91%E5%80%91%E9%83%BD%E8%AA%A4%E6%9C%83%E7%94%9F%E7%94%A2%E5%8A%9B%E7%9A%84%E6%84%8F%E7%BE%A9%E4%BA%86/</guid>
      <description>&lt;h1 id=&#34;慢速工作力---也許我們都誤會生產力的意義了&#34;&gt;慢速工作力 - 也許我們都誤會生產力的意義了&lt;/h1&gt;
&lt;p&gt;啊～～生產力，讓人又愛又恨的生產力。每當我們感嘆工作太過忙碌，或是遲遲無法達成目標，提高生產力往往是最終結論。然而隨著一款又一款號稱能提高生產力的應用程式和工具問世，我們依舊受困於永無停歇的工作追逐戰。應許之地就在前方，但無論列車如何加快，隧道永遠看不見盡頭。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;知識工作者疲憊不堪 ── 被越來越殘酷無情的忙碌折磨得筋疲力盡。與其說疫情引發了這項趨勢，倒不如說疫情將最惡劣的過度忙碌推到了令人無法忍受的地步。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Carl Newport 在其最新著作《&lt;a href=&#34;https://readmoo.com/book/210362853000101&#34;&gt;慢速工作力&lt;/a&gt;》提出了上述警訊。大家普遍相信唯有不斷忙碌，才能拿出傑出的工作表現，所以我們追求更快速地回覆電子郵件和 LINE 訊息、努力加入更多場會議、自發延長工作時數……結果換回倦怠以及功能受損的肝。&lt;/p&gt;
&lt;p&gt;經過多年的訪談、研究和推敲，Carl Newport 認為知識工作者的問題不在於廣義上的生產力夠不夠高，而在於當前社會大眾對於「**生產力」**一詞從最初便有誤解，導致後續越走越偏。 他提出了一種名為「&lt;strong&gt;慢速工作力&lt;/strong&gt;」的替代方案，倡議用更緩慢的概念來理解生產力的根本意義。&lt;/p&gt;
&lt;p&gt;慢速工作力不需要瘋狂忙碌，就能讓工作既有意義又有價值。Carl Newport 將它分成以下三項原則說明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;少做一些事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以自然的步調工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;執著於品質。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而就像王道故事決戰前都要先認識反派的成魔之道，我們也需要來了解一下生產力是如何轉變為包著糖衣的詛咒。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;偽戀賺人熱淚偽生產力使人倦怠&#34;&gt;偽戀賺人熱淚、偽生產力使人倦怠&lt;/h2&gt;
&lt;p&gt;作者毫不囉唆，直接指出當前知識工作圈認知的生產力是偽生產力~~、是修正主義~~。因為這套生產力其實是從一、二級產業強加移植的。一、二級產業即為農業和製造業。&lt;/p&gt;
&lt;p&gt;由於一、二級產業講究於可視的產出，所以生產力定義和追蹤起來非常明確。然而當今知識產業的工作內容千變萬化，光是一個職位就肩負多種職能與責任，而且知識工作相較於傳統農業或製造業有著更高的個人自主性 (大家用自己一套方式工作)，造成&lt;strong&gt;知識工作者始終難以對「生產力」的涵義達成共識&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;既然討論不出個所以然，不如就直接參考過往的成功經驗吧！於是&lt;strong&gt;知識工作者們紛紛將可見的活動當作實際生產力的粗略替代指標&lt;/strong&gt;。故事的結局我們再熟悉不過：更快的客戶回覆時間、更多陌生開發電話和信件，以及更長的工作時數。&lt;/p&gt;
&lt;p&gt;可以說知識工作者一直在追逐著海市蜃樓。我尤其對作者這句話印象深刻：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;偽生產力不是一項可以簡單解釋的規範化制度，更像是一種心情 ──&lt;strong&gt;一種透過狂熱動作來支撐有意義活動的總體氛圍&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;簡單來說，偽生產力容易讓大家「裝忙」。加上 Slack、LINE、視訊軟體等工具問世，我們更能不費吹灰之力傳送訊息顯示自己很忙，所以大家花越來越多時間傳訊息、開會，盡可能快速且發了瘋似地討論工作。生活各個角落都塞滿了工作，而我們則虔誠地相信這樣終將能累積成具有意義的東西。講難聽點，我們正盲目崇拜著名為生產力的邪教。&lt;/p&gt;
&lt;p&gt;這便是為什麼 Carl Newport 希望邀請大家一起重新思考生產力和工作的本質，並提出可行的替代方案。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;原則一少做些事情&#34;&gt;原則一、少做些事情&lt;/h2&gt;
&lt;p&gt;少做事情可以得到更好的結果？這其實違背了我們當代人對行動的偏好，因為我們普遍相信做越多事情等於擁有更多選擇，所以會產生更多獲取回報的機會。不過 Carl Newport 提出了兩個文學界和商界的案例來挑戰這個觀念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;《傲慢與偏見》的作者珍 . 奧斯汀在人生最繁忙的時期，因緣際會之下大幅減輕了肩上的義務，才終於能夠好好完成最棒的作品，而非民間遙傳的掌握零碎時間撥空寫作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;賈伯斯重新回到蘋果後，大幅度刪減產品線，將資源和動能投入到少數幾項產品，扭轉了蘋果公司的頹勢。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;少做一些事情不只&lt;strong&gt;增加了用於有效活動的工作時數&lt;/strong&gt;，更&lt;strong&gt;提升了這些時間的品質&lt;/strong&gt;。其實很好理解，因為我們不必到處滅火處理瑣事，而是專心聚焦在少數的重要專案上，便有餘裕嘗試更開闊的可能性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;努力減少你必須履行的職責，直到你能輕易想像自己擁有綽綽有餘的時間來完成它們。借助較輕的負荷，更充分地投入和推展最重要的少數幾項計畫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至於要如何在生活中實踐這個主張，作者提供了以下方法給我們參考。&lt;/p&gt;
&lt;h3 id=&#34;減少主要目標才能管理工作量&#34;&gt;減少主要目標才能管理工作量&lt;/h3&gt;
&lt;p&gt;作者認為工作超載並非知識工作與生俱來的詛咒，而是我們管理自身工作量的方式過於粗糙所產生的副作用。針對這個問題，他建議我們&lt;strong&gt;小至每日、大至生涯都該減少主要目標&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每天只做一件大事，能帶來和諧的穩定性和踏實感。實際上我們取得了真正的進展，內心世界也抑制了焦慮。如此步調符合慢速工作力背後的哲學，雖然短期內看似緩慢，但若將鏡頭拉遠，經過數週、數月所累積出的成果將會非常豐碩。&lt;/p&gt;
&lt;p&gt;這個方法和原子習慣有異曲同工之妙，但我認為更強調「重質不重量」的層面。畢竟一次安排太多目標，後續往往自然消滅到一個都不剩，那還不如聚焦在少數重要的目標上，依循自然、踏實的節奏努力。&lt;/p&gt;
&lt;h3 id=&#34;評估新專案或合理的工作量時要考量工作帶來的行政開銷&#34;&gt;評估新專案或合理的工作量時，要考量工作帶來的行政開銷&lt;/h3&gt;
&lt;p&gt;工作不會憑空產生，不是我們為自己設定目標，就是職場受他人委託辦事。這個時候若沒有堅守住「合理的工作量」，就很容易陷入偽生產力的惡性循環中。合理的工作量因人而異，重點是要&lt;strong&gt;對排程保持清晰和可控&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;作者提醒我們不要忘記&lt;strong&gt;每項職責和任務都伴隨經常性的行政開銷&lt;/strong&gt;。例如為了搜集資訊而衍生的一長串郵件往來，或是無性生殖冒出來的會議。隨著待辦清單逐漸加長，我們得付出的行政開銷稅額就越來越高。由於一天就 24 小時，這些行政雜務勢必擠壓其他核心工作的時間，造成你收好筆電、吞下淚水、打卡下班後回家繼續做那些真正重要的工作。&lt;/p&gt;
&lt;p&gt;此外很多時候，讓我們分心的不是實際執行行政瑣事，而是要費心記住它、為它操心的腦力流失。總結來說，如果我們能盡量減少這類準備工作，就能遏止行政開銷稅給工作本身帶來的影響。&lt;/p&gt;
&lt;p&gt;有鑑於此，作者建議在&lt;strong&gt;選擇新專案時，要優先考慮行政、瑣碎開銷最少的選項&lt;/strong&gt;，不要把專案難度或總時數當作遴選指標。&lt;/p&gt;
&lt;h3 id=&#34;採取拉式作業模式來維持合理工作量&#34;&gt;採取拉式作業模式來維持合理工作量&lt;/h3&gt;
&lt;p&gt;作者發現許多人日常工作都是採用「推式作業」，也就是一旦判定手上任務該由其他人接手就直接將工作給推過去，也不理會對方是否早已工作量爆表。能當甩鍋方當然痛快，但我們更常淪為目睹工作不斷被推過來的接收方。因此 Carl Newport 提倡改採「&lt;strong&gt;拉式作業&lt;/strong&gt;」模式。&lt;/p&gt;
&lt;p&gt;所謂拉式作業是指工作會先掉入暫存區，當我們確定現役工作區出現空檔，再主動從暫存區拉入新的工作。這樣的好處是整體流程步調將隨著運作最緩慢的階段開始調整，如此透明性進而幫助工作者找出系統失衡的地方。上述當然是理想狀態，而我們都知道現實總骨感，因此作者也建議我們&lt;strong&gt;以共事者察覺不到的方式，將拉式工作模式帶入到制度中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;作者指出我們常誤以為共事者只關心盡快取得成果，但其實很多時候他們真正想要的是能將工作交付出去，壓根不擔心對方會不會完成工作。觀察到這點後，我們應該適時提出「&lt;strong&gt;反向任務清單&lt;/strong&gt;」，要求對方花更多時間說明需求，這樣除了讓後續執行更加順利，有時甚至能直接讓對方打消推派工作的念頭。&lt;/p&gt;
&lt;p&gt;所以一份淺移默化的拉式工作流程大概長這樣：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新工作先到暫存區&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我們讓對方知道反向任務清單的資訊&lt;/p&gt;</description>
    </item>
    <item>
      <title>讀書心得 - 給予</title>
      <link>http://localhost:1313/posts/reading/giveness/</link>
      <pubDate>Mon, 27 Jan 2025 17:04:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/reading/giveness/</guid>
      <description>&lt;h2 id=&#34;施比受更有福終究是迷信和話術嗎&#34;&gt;施比受更有福終究是迷信和話術嗎？&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;Giveness&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/img/kelly-sikkema-XX2WTbLr3r8-unsplash.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;從小我們都被灌輸「施比受更有福」的觀念，即使幫助他人沒有即時性的好處，也&lt;strong&gt;應該&lt;/strong&gt;要慷慨解囊。然而隨著年紀增長、見識開闊才赫然發現，似乎那些凡事以自身利益出發的人往往更有成就。然後我們不免感嘆又被師長狠狠騙了一輪，就像好好讀書工作，自然能交到女朋友一樣，卻忘了哥布林終究是異性絕緣體。&lt;/p&gt;
&lt;p&gt;難道「施比受更有福」真的只是用來騙小孩的話術嗎？&lt;/p&gt;
&lt;p&gt;華盛頓商學院教授&lt;a href=&#34;https://readmoo.com/book/210148666000101?srsltid=AfmBOorYibdFTpk5g1DJ42yVkdI3pj3qVh8yS1ICKuw8E5xFts2S6Ucu&#34;&gt;亞當 . 葛蘭特的《給予》&lt;/a&gt;一書就在回應這個看似成理的誤解。&lt;/p&gt;
&lt;p&gt;他同意&lt;strong&gt;我們的成功取決於我們與他人互動的方式&lt;/strong&gt;，但與其選擇盡量搜刮利益，或許不計較得失、盡可能貢獻出最大價值才是終極的成功之道。他在書中從四大領域切入，探討索取者、互利者、給予者的差異：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;人脈交際 - 新建人脈與鞏固舊有人脈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合作原則 - 與同事高效合作並贏得信任與尊敬&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;評價他人 - 培育人才，並激發他人潛力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;影響他人 - 表達、銷售、協商以及發揮影響力&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;結果他發現了一個令人意想不到的模式：&lt;strong&gt;表現最差和最好的人都是給予者&lt;/strong&gt;。還有這種事情？最好和最爛的全包牌就對了？&lt;/p&gt;
&lt;p&gt;根據他的研究，樂於付出確實可能成為絆腳石，不過這是在零和或非輸即贏的情況下才容易發生。而這種非黑即白的場面對大眾來說比較好理解，所以造成給予者通常沒有好下場的誤解。實際上，&lt;strong&gt;人生中並非一場零和賽局，而選擇成為給予者從長遠來看，往往能夠滿載而歸&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其中還有一個關鍵：現代資訊傳播越來越方便及快速，有利於給予者脫穎而出。因為給予者要贏得他人善意和信任需要一些時間，而現代社會在社交媒體加持下，人際關係和聲譽建立起來都更加容易，加快了給予者邁向成功的腳步。&lt;/p&gt;
&lt;p&gt;以下我們就先來看看亞當 . 葛蘭特發現給予者在人脈經營方面的獨特認知。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;給予者對人脈的認知創造價值&#34;&gt;給予者對人脈的認知：創造價值&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;人脈是替所有人創造價值的管道，而非獨善其身的工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般索取者和互利者在人脈網絡中也會付出，但他們付出是策略性的，也就是期待對方投桃報李，或甚至 ROI 爆表。所以一旦對方無法在短期內回報他們，索取者和互利者便不願意為對方付出，因為投資報酬率太差了。&lt;/p&gt;
&lt;p&gt;相較之下，給予者相信&lt;strong&gt;人脈是替大眾創造價值的管道&lt;/strong&gt;。他們也相信秉持創造價值的信念付出，可以徹底改造傳統的利益交換思維，讓人脈網絡中的所有成員最大稱度受惠。人人有飯吃、人人有功練。&lt;/p&gt;
&lt;p&gt;理念很好，聽起來很偉大，但回到現實，這樣做憑什麼讓給予者成為人脈網絡中的最終贏家？&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&#34;給予者是人脈網絡中注入能量的太陽&#34;&gt;給予者是人脈網絡中注入能量的太陽&lt;/h3&gt;
&lt;p&gt;&lt;del&gt;東方紅、太陽升，東方出了個毛澤東&lt;/del&gt; 亞當 . 葛蘭特提出傳統研究社群網絡的學者習慣追蹤資訊交換，也就是人與人之間傳遞知識的狀況，但後來發現&lt;strong&gt;人脈網絡中的能量也能夠繪製出來&lt;/strong&gt;。而且畫出來宛若星系模型一般。&lt;/p&gt;
&lt;p&gt;在「能量網絡圖」中，索取者就像黑洞，不斷吸走旁人的能量；而給予者則像太陽替旁人創作貢獻的機會，自然容易取得好感、信任、聲望。我知道太靠近太陽會被燒成灰，那我們不妨想像給予者像冬天難得探頭的暖陽，任誰都想沐浴在其溫暖的光輝之下。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&#34;給予者更容易和次要休眠人脈搭上線&#34;&gt;給予者更容易和次要、休眠人脈搭上線&lt;/h3&gt;
&lt;p&gt;一般我們想到人脈，都會聯想到業務做陌生開發，越多新鮮、強烈的連結越好，但亞當 . 葛蘭特提出了另一種思維：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要人脈可提供強而有力的連結，但次要人脈則是良好的中介橋樑，是取得新資源的高效管道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因為我們親近的主要人脈通常跟我們處在差不多的社交圈、同溫層，所以次要人脈比較可能帶我們深入不同的人脈網絡，找到更多潛在機會。休眠人脈同理，而且聯絡休眠人脈還能避免與次要人脈交涉的尷尬。&lt;/p&gt;
&lt;p&gt;回到給予者本身。給予者平時慷慨分享自己的知識和技術但不談利益交換，這樣當他們尋求幫助時，大家通常都非常樂意協助。換個角度想，給予者等於取得主要人脈和次要人脈好處的捷徑：&lt;strong&gt;透過主要人脈的信任，搭配上次要人脈的資訊，順利重新搭上線&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&#34;給予者的人脈所帶來的價值通常更持久&#34;&gt;給予者的人脈所帶來的價值通常更持久&lt;/h3&gt;
&lt;p&gt;綜合上述原因，儘管給予者和索取者都可能經營出廣大的人脈，但&lt;strong&gt;給予者更能夠經營出兼具廣度和深度的人脈&lt;/strong&gt;。而這樣的人脈長期價值通常更加可觀。&lt;/p&gt;
&lt;p&gt;索取者因為擅長向上管理而得勢，卻也因此容易在得勢後虧待同儕或下屬，而被他眼中「好了，這傢伙沒有利用價值啦」的人反咬而失勢。至於互利者人脈因為其利益交換掛帥的特性，廣度遜於給予者和索取者。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;給予者注重價值創造及團隊成就&#34;&gt;給予者注重價值創造及團隊成就&lt;/h2&gt;
&lt;p&gt;談到團隊合作，我們要先有個認知，那就是&lt;strong&gt;即便看似獨立的腦力工作，也十分倚重團隊合作&lt;/strong&gt;。我們常以為知識工作者能夠將知識打包帶走，但事實上就算是公認的聰明狠角色，少了團隊一樣難以大施長才。&lt;/p&gt;
&lt;p&gt;前面提過給予者在人脈網絡中就像太陽為他人注入能量。來到團隊合作層面，給予者會&lt;strong&gt;用自己的才智來放大他人的智慧與能力&lt;/strong&gt;，讓大家頭上燈泡亮起來、士氣大振。而這也和給予者對於成功的定義與想像有關，他們認為團體共存共榮、集結眾人之力才能帶來力量，若自己對團體有所貢獻，所有人都會有更好的成就，而這便是所謂的成功。&lt;/p&gt;
&lt;p&gt;不過要強調，&lt;strong&gt;給予者並非全然不在意自己的發展，只是他們選擇用不同的途徑來達成目標&lt;/strong&gt;。表現最差的給予者 (濫好人)，以及表現最好的給予者差別即在與此。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&#34;給予者注重團隊成就避免責任認知偏誤&#34;&gt;給予者注重團隊成就，避免責任認知偏誤&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;責任認知偏誤 (responsibility bias)&lt;/strong&gt; 是指我們會放大自己在團體中的貢獻比例，而大多數人之所以會產生責任認知偏誤，和「資訊失調」有關。也就是說，我們深知自己給予了多少，卻不一定清楚別人付出多少，因此到了判斷功勞該歸於誰的時候，泰半較為在意自己的貢獻。索取者尤其容易產生責任認知偏誤。&lt;/p&gt;
&lt;p&gt;而由於給予者對成功的定義著重在創造價值、共存共榮，自然會注意整個團隊的成就，相較之下不容易出現責任認知偏誤。你好、我好、大家好。我多給一點、你多給一點、大家都多給一點，這塊餅就越來越大了。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&#34;給予者能為團隊營造出心理安全感&#34;&gt;給予者能為團隊營造出心理安全感&lt;/h3&gt;
&lt;p&gt;所謂的心理安全感是指大家在團體中&lt;strong&gt;相信自己做有風險的事情也不會受到懲罰&lt;/strong&gt;。根據研究，這樣的環境有助於學習以及創新，畢竟人只要想著「我就怕會被罵啊」，便容易裹足不前、不敢接受新事物或挑戰。而給予者平時嚴以律己、寬以待人，尤其能為團隊營造心理安全感。&lt;/p&gt;
&lt;p&gt;除此之外，由於給予者具備同理心，通常能夠克服「觀點落差」。舉例來說，今天團隊有人失戀了，身為一隻普通的哥布林此生自然和戀愛無緣，因此容易評論：「對象再找就好啦，幹嘛搞到像世界末日一樣啊？」但若是具備同理心的給予型哥布林則會反思：「嗯……雖然我是個戀愛絕緣體，沒有失戀的經驗，但那想必很難受、需要時間和空間來調適吧」，因而選擇給予對方心情上的支持。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;team&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/img/vlad-hilitanu-1FI2QAYPa-Y-unsplash.jpg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;給予者的協商之道&#34;&gt;給予者的協商之道&lt;/h2&gt;
&lt;p&gt;提及影響力，我們習慣聯想到講話鏗鏘有力、態度堅定不移、不放手直到夢想到手的索取型人物。但亞當 ．葛蘭特發現，給予者在協商、發揮影響力方面其實不輸他人，關鍵就在於&lt;strong&gt;柔軟溝通術&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h3 id=&#34;柔軟溝通術重視他人的觀點和利益&#34;&gt;柔軟溝通術：重視他人的觀點和利益&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;採取柔軟溝通法的人通常言語平實，不把話說滿，會大量聆聽別人的意見，他們言談間流露出自己的不完美及短處，也會使用免責的話語、委婉的規避語及不確定的語氣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老實說看到這邊，我對於免責的話語和不確定的語氣心存懷疑，這樣真的能夠取信於人嗎？不知道是不是翻譯的問題，但我認為作者想強調的應該是：&lt;strong&gt;用討論的心態，從對方的觀點和利益出發去溝通。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>自由書寫術 - 找回靈感的絕佳方法</title>
      <link>http://localhost:1313/posts/reading/%E8%87%AA%E7%94%B1%E6%9B%B8%E5%AF%AB%E8%A1%93---%E6%89%BE%E5%9B%9E%E9%9D%88%E6%84%9F%E7%9A%84%E7%B5%95%E4%BD%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 13 Jan 2025 15:16:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/reading/%E8%87%AA%E7%94%B1%E6%9B%B8%E5%AF%AB%E8%A1%93---%E6%89%BE%E5%9B%9E%E9%9D%88%E6%84%9F%E7%9A%84%E7%B5%95%E4%BD%B3%E6%96%B9%E6%B3%95/</guid>
      <description>學會自由書寫，主動挖掘靈感，解放大腦內的豐富素材。不用再煩惱沒有好想法了！</description>
    </item>
    <item>
      <title>哥布林學 Python 物件導向 (OOP)</title>
      <link>http://localhost:1313/posts/programming/python/oop-overview/</link>
      <pubDate>Sun, 16 Feb 2025 13:09:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/programming/python/oop-overview/</guid>
      <description>透過 Python 學習封裝、抽象化、繼承、多型等物件導向概念</description>
    </item>
    <item>
      <title>初探 Python 字典 (Dictionary)</title>
      <link>http://localhost:1313/posts/programming/python/dictionary/</link>
      <pubDate>Sat, 25 Jan 2025 22:47:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/programming/python/dictionary/</guid>
      <description>&lt;h2 id=&#34;什麼是字典-dictionary&#34;&gt;什麼是字典 (Dictionary)？&lt;/h2&gt;
&lt;p&gt;在 Python 中，字典用來儲存 &lt;code&gt;key -&amp;gt; value&lt;/code&gt; 組合的資料，和 JavaScript 的物件 (objects) 非常類似。字典使用 &lt;code&gt;{}&lt;/code&gt; 來包裹住資料，每個鍵 (key) 都會對應到一個值 (value)：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Xavier&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pet&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Mimiball&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;不要重複-key&#34;&gt;不要重複 &lt;code&gt;key&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;列表利用索引 (index) 來辨別資料，而字典則是依靠鍵 (key)。所以實作上我們&lt;strong&gt;不應該在字典中重複使用 key&lt;/strong&gt;，如果不信邪，你會發現原先的值被覆寫過去了！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Xavier&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Neo-Xavier&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pet&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Mimiball&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面範例中，哥布林的名字從 &lt;code&gt;Xavier&lt;/code&gt; 變成了 &lt;code&gt;Neo-Xavier&lt;/code&gt;，因為兩筆資料的 key 都是 &lt;code&gt;name&lt;/code&gt;，而後面的資料覆寫了前面一筆 key 相同的資料。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;操作字典中的資料&#34;&gt;操作字典中的資料&lt;/h2&gt;
&lt;p&gt;基本上不脫離取、增、刪、變四大操作，下面逐一說明。&lt;/p&gt;
&lt;h3 id=&#34;提取字典中的資料&#34;&gt;提取字典中的資料&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;[]&lt;/code&gt; 來提取字典中的資料。前面提過字典是靠 key 來辨別每一筆資料，所以我們需要在 &lt;code&gt;[]&lt;/code&gt; 帶入特定資料的 key，而且要用字串的方式帶入，也就是前後加上 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Xavier&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pet&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Mimiball&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(goblin[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;新增字典資料&#34;&gt;新增字典資料&lt;/h3&gt;
&lt;p&gt;實務上我們常常會先建立一個空字典，然後依照商業邏輯陸續新增動態資料到字典中。而新增資料到字典的方式和提取資料大同小異，一樣使用 &lt;code&gt;[key_name]&lt;/code&gt; 的模式即可。&lt;/p&gt;</description>
    </item>
    <item>
      <title>初探 Python 元組 (Tuples)</title>
      <link>http://localhost:1313/posts/programming/python/tuples/</link>
      <pubDate>Thu, 23 Jan 2025 22:15:24 +0800</pubDate>
      <guid>http://localhost:1313/posts/programming/python/tuples/</guid>
      <description>&lt;h2 id=&#34;什麼是元組-tuples&#34;&gt;什麼是元組 (Tuples)？&lt;/h2&gt;
&lt;p&gt;元組是 Python 其中一種資料集合的型別，具有以下兩種特色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;資料有序排列，可用索引提取資料&lt;/li&gt;
&lt;li&gt;資料無法變更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以基本上，我們可以將元組看作是&lt;strong&gt;固定長定、無法變更的列表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在建立列表時，我們通常不會置入不同型別的資料，但這在元組中不成問題，因為元組的長度是固定的，所以能輕易追蹤哪個索引儲存哪種型別的資料。&lt;/p&gt;
&lt;p&gt;和列表的 &lt;code&gt;[]&lt;/code&gt; 不同，元組需要使用 &lt;code&gt;()&lt;/code&gt; 來建立：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;my_tuple &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;this is a tuple&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(my_tuple[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# this is a tuple&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(my_tuple[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 45&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(my_tuple[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;元組通常用來儲存少量、固定不變的資料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;元組和列表混用&#34;&gt;元組和列表混用&lt;/h2&gt;
&lt;p&gt;由於元組本身就是資料的容器，所以我們&lt;strong&gt;可以將多個元組儲存在列表當中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;語法上和一般資料相同，用半形逗號區隔不同的元組，然後每個元組在列表中都有自己的索引。也就是說，當我們要提取列表中的元組資料，第一個索引代表要選取哪個元組，而第二個索引代表要選取該元組中哪筆資料。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;my_tuples &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;this is the first tuple in the list&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;),(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;this is the second tuple in the list&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(my_tuples[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]) &lt;span style=&#34;color:#75715e&#34;&gt;# this is the first tuple in the list&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(my_tuples[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#75715e&#34;&gt;# 45&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(my_tuples[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]) &lt;span style=&#34;color:#75715e&#34;&gt;# this is the second tuple in the list&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(my_tuples[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]) &lt;span style=&#34;color:#75715e&#34;&gt;# False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;開箱元組&#34;&gt;開箱元組&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Tuple Unpacking&lt;/code&gt; 好像網路上有人翻譯成元組拆包，但我自己是習慣用「開箱元組」來指稱，因為開箱聽起來比較開心。&lt;/p&gt;</description>
    </item>
    <item>
      <title>初探 Python 列表 (List) - 續</title>
      <link>http://localhost:1313/posts/programming/python/list_continued/</link>
      <pubDate>Mon, 20 Jan 2025 22:30:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/programming/python/list_continued/</guid>
      <description>&lt;h2 id=&#34;不靠索引也能提取列表資料&#34;&gt;不靠索引也能提取列表資料&lt;/h2&gt;
&lt;p&gt;如果不需要更新列表中的資料，我們其實可以用更精簡的語法去遞迴列表。&lt;code&gt;in&lt;/code&gt; 關鍵字負責宣告 &lt;code&gt;friend&lt;/code&gt; 變數，儲存每一次遞迴所提取的列表資料：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;friends &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Cute Goblin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Big Goblin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Small Goblin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Taipei Goblin&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; friend &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; friends:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(friend)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Cute Goblin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Big Goblin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Small Goblin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Taipei Goblin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;
這種簡潔的語法在尋找列表資料時尤其方便，因為我們只在乎列表的資料值，索引直接捨棄也不用在意，像極了哥布林的愛情：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;contains_small_goblin&lt;/span&gt;(friends):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    found &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; friend &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; friends:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; friend &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Small Goblin&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            found &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; found
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;尋找最大數&#34;&gt;尋找最大數&lt;/h2&gt;
&lt;p&gt;這算是個小技巧(?)，如果我們想從列表中找出最大數，可以先將初始值宣告為&lt;code&gt;float(&amp;quot;-inf&amp;quot;)&lt;/code&gt;，這樣便能確保列表中每個數字都比它更大。接下來用遞迴陸續找出更大的數值，然後取代它就可以了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_max&lt;/span&gt;(nums):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    max_so_far &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-inf&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; nums:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_so_far:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            max_so_far &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; num
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max_so_far
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;
同理，若是要找出最小數，將初始值變數宣告為&lt;code&gt;float(&amp;quot;inf&amp;quot;)&lt;/code&gt;即可。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;切割列表&#34;&gt;切割列表&lt;/h2&gt;
&lt;p&gt;我們可以用 &lt;code&gt;:&lt;/code&gt; 切割出列表的特定區段，那回傳的會是一個新的列表。除了從哪裡開始、到哪裡結束之外，我們還能指定中間要跳過幾筆資料 (step)。&lt;/p&gt;</description>
    </item>
    <item>
      <title>初探 Python 列表 (List)</title>
      <link>http://localhost:1313/posts/programming/python/list/</link>
      <pubDate>Sun, 19 Jan 2025 15:34:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/programming/python/list/</guid>
      <description>&lt;h2 id=&#34;什麼是列表&#34;&gt;什麼是列表？&lt;/h2&gt;
&lt;p&gt;程式語言通常都會有&lt;strong&gt;負責組織、儲存多筆資料&lt;/strong&gt;的資料型別。在 JavaScript 和 Golang 中，這種資料型別被稱為陣列 (array)，而 Python 則是列表 (list)。&lt;/p&gt;
&lt;p&gt;Python 中的列表用 &lt;code&gt;[...]&lt;/code&gt; 宣告，每項資料中間以半形逗號區隔：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;friends &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Cute Goblin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Big Goblin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Small Goblin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Taipei Goblin&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;上面的列表中清一色都是字串，但我們其實&lt;strong&gt;可以在列表中加入各種型別的資料&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若資料量持續增加，我們可以將每筆資料一行一行拆開，讓程式碼更容易閱讀。畢竟很多東西，不是越長就越好：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;friends &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Cute Goblin&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Big Goblin&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Small Goblin&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Taipei Goblin&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;goblin_age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;用索-index-提取列表中的資料&#34;&gt;用索 (index) 提取列表中的資料&lt;/h2&gt;
&lt;p&gt;首先我們要知道&lt;strong&gt;在程式的世界，通常都是從 0 開始計數&lt;/strong&gt;的，而非日常生活中直覺的 1。&lt;/p&gt;
&lt;p&gt;列表中每一筆資料都有其索引 (index)，也就是該筆資料在列表中的位置。再提醒一次，務必要從 0 開始算起。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;friends &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Cute Goblin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Big Goblin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Small Goblin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Taipei Goblin&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;
以上述列表為例，每筆資料的索引如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：&lt;code&gt;Cute Goblin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1：&lt;code&gt;Big Goblin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2：&lt;code&gt;Small Goblin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3：&lt;code&gt;Taipei Goblin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再舉個例子，&lt;strong&gt;索引 1 等於列表當中第二筆資料&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>迴圈 - 以 Python 為例</title>
      <link>http://localhost:1313/posts/programming/python/loop/</link>
      <pubDate>Sat, 18 Jan 2025 11:54:14 +0800</pubDate>
      <guid>http://localhost:1313/posts/programming/python/loop/</guid>
      <description>&lt;h2 id=&#34;為什麼要有迴圈&#34;&gt;為什麼要有迴圈？&lt;/h2&gt;
&lt;p&gt;原因只有一個，那就是人類很懶，假設今天要輸出 100 萬筆資料，我們需要一筆一筆手刻出來嗎？在被主管開除之前，我們應該會先無聊到開始裸奔吧。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Patrick Star wants to run naked&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/img/patrick_star_nacked.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;這個時候善用迴圈，用一組程式碼就能搞定大量的重複工作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1_000_000&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(i)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;拆解-for-迴圈運作流程&#34;&gt;拆解 for 迴圈運作流程&lt;/h2&gt;
&lt;p&gt;上面以 &lt;code&gt;for&lt;/code&gt; 關鍵字起頭的迴圈被稱為 &lt;strong&gt;for 迴圈&lt;/strong&gt;，除了 Python 之外，Golang、JavaScript 等等眾多程式語言也都有類似的語法。本篇文章就以 Python 為例，拆解 for 迴圈的運作流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;迴圈從 i 等於 0 啟動 -&amp;gt; &lt;code&gt;i in range(0)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;檢查若 i 不少於 1,000,000 就跳出迴圈運作 -&amp;gt; &lt;code&gt;range(0, 1_000_000)&lt;/code&gt;，否則繼續執行以下動作:
&lt;ul&gt;
&lt;li&gt;列印出 i 變數 -&amp;gt; &lt;code&gt;print(i)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;i 變數值加一 (&lt;code&gt;range&lt;/code&gt; 預設會加一)&lt;/li&gt;
&lt;li&gt;回到第二步驟檢查 i 是否不少於 1,000,000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後我們會看到 0 ~ 999,999 列印出來。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Python 中，&lt;code&gt;range(a, b)&lt;/code&gt; 會包含 &lt;code&gt;a&lt;/code&gt; 但不包含 &lt;code&gt;b&lt;/code&gt;。所以 &lt;code&gt;range(0, 1_000_000)&lt;/code&gt; 才不會列印出 1,000,000。&lt;/p&gt;</description>
    </item>
    <item>
      <title>作用域 - 以 Python 為例</title>
      <link>http://localhost:1313/posts/programming/python/scope/</link>
      <pubDate>Wed, 15 Jan 2025 15:16:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/programming/python/scope/</guid>
      <description>&lt;h2 id=&#34;什麼是作用域&#34;&gt;什麼是作用域？&lt;/h2&gt;
&lt;p&gt;作用域 (Scope) 是指&lt;strong&gt;變數或函示名稱可以被使用的範圍&lt;/strong&gt;。我自己是想像成結界，外面的世界無法接觸、取用到結界內的萬事萬物。&lt;/p&gt;
&lt;p&gt;舉例來說，當我們在函式中建立一個變數，包含給函示參數，那這些資料就無法在函示的作用域範圍之外使用，會跑出該變數沒有定義的錯誤。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(x, y):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; y
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; add(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(x) &lt;span style=&#34;color:#75715e&#34;&gt;# ERROR! &amp;#34;name &amp;#39;x&amp;#39; is not defined&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;
上述範例中，&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都是 &lt;code&gt;add&lt;/code&gt; 函式的參數，因此只能在 &lt;code&gt;add&lt;/code&gt; 函式作用域範圍內被使用。我們在作用域之外嘗試列印 &lt;code&gt;x&lt;/code&gt;，Python 的編譯器會跳出 &lt;code&gt;x&lt;/code&gt; 沒有被定義的錯誤警告。&lt;/p&gt;
&lt;h2 id=&#34;全域作用域&#34;&gt;全域作用域&lt;/h2&gt;
&lt;p&gt;我們知道函式中所定義的變數和參數，是無法在函式作用域以外被使用的。但如果今天有多個函式都要用同一組變數該怎麼辦呢？我們可以在全域環境中定義變數，這樣每個函式都能夠取用該變數了。&lt;/p&gt;
&lt;p&gt;以結界來比喻，我覺得就像結界內的人可以把外面世界的物品拉進去，但外部世界的人無法看透結界內發生什麼事情，自然也就無法取用結界內的物品了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;outside_stuff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pull me in baby!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pull_outside_stuff_into_function_scope&lt;/span&gt;(target):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; outside_stuff &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; - success&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(pull_outside_stuff(outside_stuff))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;
上述範例中，&lt;code&gt;pull_outside_stuff_into_function_scope&lt;/code&gt; 最終會成功回傳 &lt;code&gt;pull me in baby! - success&lt;/code&gt;。因為 &lt;code&gt;outside_stuff&lt;/code&gt; 變數是在權域作用域 (global scope) 定義的，所以能夠被函式拉到函式作用域當中使用。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
